import User, { IUser } from "../models/User";
import bcrypt from "bcryptjs";
import mongoose from "mongoose";
import {
  sendResetPasswordEmail,
  generateResetToken,
} from "../services/authService";
import PasswordReset from "../models/PasswordReset";

/**
 * L·∫•y th√¥ng tin ng∆∞·ªùi d√πng theo ID
 */
export const getUserById = async (userId: string): Promise<IUser | null> => {
  try {
    console.log(`üîç [userService] T√¨m user v·ªõi ID: ${userId}`);

    // Ki·ªÉm tra ID h·ª£p l·ªá
    if (!mongoose.Types.ObjectId.isValid(userId)) {
      console.error(`‚ùå [userService] ID kh√¥ng h·ª£p l·ªá: ${userId}`);
      return null;
    }

    const user = await User.findById(userId).select("-password");

    if (!user) {
      console.log(`‚ùå [userService] Kh√¥ng t√¨m th·∫•y user v·ªõi ID: ${userId}`);
      return null;
    }

    console.log(`‚úÖ [userService] ƒê√£ t√¨m th·∫•y user: ${user.fullName}`);
    return user;
  } catch (error) {
    console.error(`‚ùå [userService] L·ªói khi t√¨m user:`, error);
    throw error;
  }
};

/**
 * C·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng
 */
export const updateUserProfile = async (
  userId: string,
  profileData: Partial<IUser>
): Promise<IUser | null> => {
  try {
    console.log(`üîç [userService] C·∫≠p nh·∫≠t user v·ªõi ID: ${userId}`);
    console.log(`üîç [userService] D·ªØ li·ªáu c·∫≠p nh·∫≠t:`, profileData);

    // Lo·∫°i b·ªè c√°c tr∆∞·ªùng kh√¥ng ƒë∆∞·ª£c ph√©p c·∫≠p nh·∫≠t
    const allowedUpdates = ["fullName", "email", "phone", "avatar"];
    const filteredData: any = {};

    Object.keys(profileData).forEach((key) => {
      if (allowedUpdates.includes(key)) {
        filteredData[key] = profileData[key as keyof typeof profileData];
      }
    });

    const updatedUser = await User.findByIdAndUpdate(userId, filteredData, {
      new: true,
    }).select("-password");

    if (!updatedUser) {
      console.log(
        `‚ùå [userService] Kh√¥ng t√¨m th·∫•y user ƒë·ªÉ c·∫≠p nh·∫≠t v·ªõi ID: ${userId}`
      );
      return null;
    }

    console.log(`‚úÖ [userService] ƒê√£ c·∫≠p nh·∫≠t user: ${updatedUser.fullName}`);
    return updatedUser;
  } catch (error) {
    console.error(`‚ùå [userService] L·ªói khi c·∫≠p nh·∫≠t user:`, error);
    throw error;
  }
};

/**
 * Thay ƒë·ªïi m·∫≠t kh·∫©u ng∆∞·ªùi d√πng
 */
export const changeUserPassword = async (
  userId: string,
  currentPassword: string,
  newPassword: string
): Promise<boolean> => {
  try {
    console.log(`üîç [userService] Thay ƒë·ªïi m·∫≠t kh·∫©u cho user ID: ${userId}`);

    const user = await User.findById(userId);
    if (!user || !user.password) {
      console.log(
        `‚ùå [userService] Kh√¥ng t√¨m th·∫•y user ho·∫∑c user kh√¥ng c√≥ m·∫≠t kh·∫©u: ${userId}`
      );
      return false;
    }

    // Ki·ªÉm tra m·∫≠t kh·∫©u hi·ªán t·∫°i
    const isMatch = await bcrypt.compare(currentPassword, user.password);
    if (!isMatch) {
      console.log(
        `‚ùå [userService] M·∫≠t kh·∫©u hi·ªán t·∫°i kh√¥ng ƒë√∫ng cho user: ${userId}`
      );
      return false;
    }

    // M√£ h√≥a m·∫≠t kh·∫©u m·ªõi
    const hashedPassword = await bcrypt.hash(newPassword, 10);
    user.password = hashedPassword;
    await user.save();

    console.log(
      `‚úÖ [userService] ƒê√£ thay ƒë·ªïi m·∫≠t kh·∫©u cho user: ${user.fullName}`
    );
    return true;
  } catch (error) {
    console.error(`‚ùå [userService] L·ªói khi thay ƒë·ªïi m·∫≠t kh·∫©u:`, error);
    throw error;
  }
};

/**
 * C·∫≠p nh·∫≠t m·∫≠t kh·∫©u tr·ª±c ti·∫øp (d√πng cho FaceID)
 */
export const updatePasswordDirectly = async (
  userId: string,
  newPassword: string
): Promise<boolean> => {
  try {
    console.log(
      `üîç [userService] C·∫≠p nh·∫≠t tr·ª±c ti·∫øp m·∫≠t kh·∫©u cho user ID: ${userId}`
    );

    const user = await User.findById(userId);
    if (!user) {
      console.log(`‚ùå [userService] Kh√¥ng t√¨m th·∫•y user: ${userId}`);
      return false;
    }

    // M√£ h√≥a m·∫≠t kh·∫©u m·ªõi
    const hashedPassword = await bcrypt.hash(newPassword, 10);
    user.password = hashedPassword;
    await user.save();

    console.log(
      `‚úÖ [userService] ƒê√£ c·∫≠p nh·∫≠t m·∫≠t kh·∫©u cho user: ${user.fullName}`
    );
    return true;
  } catch (error) {
    console.error(`‚ùå [userService] L·ªói khi c·∫≠p nh·∫≠t m·∫≠t kh·∫©u:`, error);
    throw error;
  }
};

/**
 * G·ª≠i m√£ x√°c nh·∫≠n ƒë·ªïi m·∫≠t kh·∫©u qua email
 */
export const sendPasswordChangeVerificationCode = async (
  email: string
): Promise<boolean> => {
  try {
    console.log(
      `üîç [userService] G·ª≠i m√£ x√°c nh·∫≠n ƒë·ªïi m·∫≠t kh·∫©u cho email: ${email}`
    );

    // S·ª≠ d·ª•ng l·∫°i h√†m t·ª´ authService ƒë·ªÉ t·∫°o v√† g·ª≠i m√£ x√°c nh·∫≠n
    const resetCode = generateResetToken();

    // X√≥a m√£ c≈© n·∫øu c√≥
    await PasswordReset.deleteMany({ email });

    // L∆∞u m√£ m·ªõi
    await new PasswordReset({
      email,
      resetCode,
      createdAt: new Date(),
    }).save();

    // G·ª≠i email
    await sendResetPasswordEmail(email);

    console.log(
      `‚úÖ [userService] ƒê√£ g·ª≠i m√£ x√°c nh·∫≠n ƒë·ªïi m·∫≠t kh·∫©u cho email: ${email}`
    );
    return true;
  } catch (error) {
    console.error(`‚ùå [userService] L·ªói khi g·ª≠i m√£ x√°c nh·∫≠n:`, error);
    throw error;
  }
};

/**
 * X√°c th·ª±c m√£ v√† ƒë·ªïi m·∫≠t kh·∫©u
 */
export const verifyCodeAndChangePassword = async (
  userId: string,
  verificationCode: string,
  newPassword: string
): Promise<boolean> => {
  try {
    console.log(
      `üîç [userService] X√°c th·ª±c m√£ v√† ƒë·ªïi m·∫≠t kh·∫©u cho user ID: ${userId}`
    );

    const user = await User.findById(userId);
    if (!user || !user.email) {
      console.log(`‚ùå [userService] Kh√¥ng t√¨m th·∫•y user ho·∫∑c email: ${userId}`);
      return false;
    }

    // T√¨m m√£ x√°c nh·∫≠n m·ªõi nh·∫•t
    const resetRecord = await PasswordReset.findOne({ email: user.email })
      .sort({ createdAt: -1 })
      .exec();

    if (!resetRecord) {
      console.log(
        `‚ùå [userService] Kh√¥ng t√¨m th·∫•y m√£ x√°c nh·∫≠n cho email: ${user.email}`
      );
      return false;
    }

    // Ki·ªÉm tra m√£ x√°c nh·∫≠n
    if (resetRecord.resetCode !== verificationCode) {
      console.log(
        `‚ùå [userService] M√£ x√°c nh·∫≠n kh√¥ng kh·ªõp cho email: ${user.email}`
      );
      return false;
    }

    // Ki·ªÉm tra th·ªùi gian h·∫øt h·∫°n (1 gi·ªù)
    if (
      resetRecord.createdAt &&
      Date.now() - resetRecord.createdAt.getTime() > 3600000
    ) {
      console.log(
        `‚ùå [userService] M√£ x√°c nh·∫≠n ƒë√£ h·∫øt h·∫°n cho email: ${user.email}`
      );
      return false;
    }

    // C·∫≠p nh·∫≠t m·∫≠t kh·∫©u
    const hashedPassword = await bcrypt.hash(newPassword, 10);
    user.password = hashedPassword;
    await user.save();

    // X√≥a m√£ x√°c nh·∫≠n ƒë√£ s·ª≠ d·ª•ng
    await PasswordReset.deleteMany({ email: user.email });

    console.log(
      `‚úÖ [userService] ƒê√£ ƒë·ªïi m·∫≠t kh·∫©u th√†nh c√¥ng cho user: ${user.fullName}`
    );
    return true;
  } catch (error) {
    console.error(
      `‚ùå [userService] L·ªói khi x√°c th·ª±c m√£ v√† ƒë·ªïi m·∫≠t kh·∫©u:`,
      error
    );
    throw error;
  }
};

/**
 * B·∫≠t/t·∫Øt FaceID
 */
export const toggleFaceID = async (
  userId: string,
  enable: boolean
): Promise<IUser | null> => {
  try {
    console.log(
      `üîç [userService] ${
        enable ? "B·∫≠t" : "T·∫Øt"
      } Face ID cho user ID: ${userId}`
    );

    const updatedUser = await User.findByIdAndUpdate(
      userId,
      { faceIDEnabled: enable },
      { new: true }
    ).select("-password");

    if (!updatedUser) {
      console.log(
        `‚ùå [userService] Kh√¥ng t√¨m th·∫•y user ƒë·ªÉ c·∫≠p nh·∫≠t Face ID: ${userId}`
      );
      return null;
    }

    console.log(
      `‚úÖ [userService] ƒê√£ ${enable ? "b·∫≠t" : "t·∫Øt"} Face ID cho user: ${
        updatedUser.fullName
      }`
    );
    return updatedUser;
  } catch (error) {
    console.error(`‚ùå [userService] L·ªói khi c·∫≠p nh·∫≠t Face ID:`, error);
    throw error;
  }
};

/**
 * C·∫≠p nh·∫≠t c√†i ƒë·∫∑t th√¥ng b√°o
 */
export const updateNotificationSettings = async (
  userId: string,
  settings: { push?: boolean; email?: boolean; sms?: boolean }
): Promise<IUser | null> => {
  try {
    console.log(`üîç [userService] C·∫≠p nh·∫≠t th√¥ng b√°o cho user ID: ${userId}`);
    console.log(`üîç [userService] C√†i ƒë·∫∑t th√¥ng b√°o:`, settings);

    // L·∫•y c√†i ƒë·∫∑t hi·ªán t·∫°i
    const user = await User.findById(userId);
    if (!user) {
      console.log(
        `‚ùå [userService] Kh√¥ng t√¨m th·∫•y user ƒë·ªÉ c·∫≠p nh·∫≠t th√¥ng b√°o: ${userId}`
      );
      return null;
    }

    // C·∫≠p nh·∫≠t c√†i ƒë·∫∑t th√¥ng b√°o
    const updatedSettings = {
      push:
        settings.push !== undefined ? settings.push : user.notifications?.push,
      email:
        settings.email !== undefined
          ? settings.email
          : user.notifications?.email,
      sms: settings.sms !== undefined ? settings.sms : user.notifications?.sms,
    };

    const updatedUser = await User.findByIdAndUpdate(
      userId,
      { notifications: updatedSettings },
      { new: true }
    ).select("-password");

    console.log(
      `‚úÖ [userService] ƒê√£ c·∫≠p nh·∫≠t th√¥ng b√°o cho user: ${updatedUser?.fullName}`
    );
    return updatedUser;
  } catch (error) {
    console.error(`‚ùå [userService] L·ªói khi c·∫≠p nh·∫≠t th√¥ng b√°o:`, error);
    throw error;
  }
};

/**
 * X√≥a t√†i kho·∫£n ng∆∞·ªùi d√πng
 */
export const deleteUserAccount = async (userId: string): Promise<boolean> => {
  try {
    console.log(`üîç [userService] X√≥a t√†i kho·∫£n user ID: ${userId}`);

    const user = await User.findById(userId);
    if (!user) {
      console.log(`‚ùå [userService] Kh√¥ng t√¨m th·∫•y user ƒë·ªÉ x√≥a: ${userId}`);
      return false;
    }

    // X√≥a user
    await User.findByIdAndDelete(userId);

    console.log(`‚úÖ [userService] ƒê√£ x√≥a t√†i kho·∫£n user: ${user.fullName}`);
    return true;
  } catch (error) {
    console.error(`‚ùå [userService] L·ªói khi x√≥a t√†i kho·∫£n:`, error);
    throw error;
  }
};
